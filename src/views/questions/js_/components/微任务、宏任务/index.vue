<template>
  <div/>
</template>

<script>
export default {
  data() {
    return {
      list: [
        'js语言的一大特点就是单线程，同一时间只能做一件事，为了协调，防止主线程不阻塞，Event Loop(事件循环)的方案应运而生',
        // 事件循环分为宏任务队列和微任务队列
        // 任务队列
        `事件循环是通过任务队列的机制来进行协调的。一个Event Loop中，可以有一个或多个任务队列；
         每个任务都有一个任务源，同一任务源的任务必须放在同一个任务队列，不同源来的则被添加到不同队列`,
        `js分为同步任务和异步任务。同步任务都在主线程上执行，形成一个执行栈；主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了
         运行结果，就在任务队列放置一个事件；一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行`,
        // 宏任务
        `每次执行栈执行的代码就是一个宏任务，浏览器为了能够使得js内部宏任务与DOM任务有序执行，会在一个宏任务执行结束后，在下一个宏任务开始
         前，对页面进行重新渲染`,
        // 微任务
        `当任务执行结束后立即执行的任务，也就是说在某一个宏任务执行完后，就会就会将它在执行期间产生的所有微任务都执行完毕（渲染前）`,
        // 运行机制
        `1.执行一个宏任务（栈中没有就从事件队列中获取）；
         2.执行过程中如果遇到微任务，就将它添加到微任务的任务队列中；
         3.宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）；
         4.当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染；
         5.渲染完毕后，js线程继续接管，开始下一个宏任务（从事件队列中获取）
        `
      ]
    }
  }
}
</script>

<style>

</style>
